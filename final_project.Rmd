---
title: "A title for your project"
author: "Your name and U number"
date: "Today's date"
output:  
    html_document:
        toc: true
        toc_depth: 4
        theme: cosmo
        number_sections: false
        toc_float: true
        highlight: pygments
        fig_width: 8
        fig_height: 4
---

# Load Libraries and set.seed()

```{r}
set.seed(8723)

library(R6)
library(tidyverse)
library(animation)
library(raster)
library(randomForest)
library(sf)
library(gridExtra)
library(viridis)
library(cowplot)
library(skimr)
library(grid)
library(knitr)
source("ABM.R")
```

```{r, include=FALSE}
knitr::opts_chunk$set(
  warning=FALSE,
  message=FALSE
)
```

# Word/figure count

Words: 1986
Figures:

# Location on GitHub

https://github.com/nickboffa/DS4B-final-report

# Project Outline

## Aim

To use environmental data, together with outputs from mechanistic models, to try to replicate (and then predict) the colonisation of Australia by cane toads using an agent-based model (ABM).

## Justification

Many attempts have been made to model the environmental niche of cane toads, but their range-shifting nature has made this difficult (Elith et. al, 2010). The traditional method is the 'correlative' approach: using a set of environmental predictor variables, together with some algorithm (e.g. GAM), to predict the fundamental niche of a species - such as in Urban et. al (2008). However, particularly, with cane toads such models tend to be inaccurate, as they have not reached equilibrium with their fundamental niche (Elith et. al, 2010). 

Kearney et. al (2008) resolved this issue by only using the physiology of cane toads to predict their fundamental niche (the 'mechanistic' approach), and found that access to breeding sites was the primary thing limiting the toads invasion inland. But this approach can only model finite biological mechanisms, and so may miss key aspects determining the toad's fundamental niche.

At the recommendation of Kearney et. al (2008) and as implemented by Elith et. al (2010), we will thus use this mechanistic output, that tells where the cane toads should be theoretically able to live, to define the pseudoabsence points that then inform our correlative model; we shall also incorporate the recent recommendations of Soley-Guardia, Alvarado-Serrano, & Anderson (2024). That said, we will ignore artificial water sources.

The key difference in this report to the primary literature is the use of an ABM. By introducing a temporal component to the model, we can predict not just where the toad's will end up, but when they will arrive there. We shall only use occurrence data up to the year 2000, so that we may validate our model with present-day data.

# Raw data description

## WorldClim 2.1 (Fick & Hijmans, 2017)

In this report we use 2 of the 19 bioclimatic variables available in WorldClim 2.1, at a resolution of 10 minutes. These variables are raster surfaces for the entire globe, where the values are the average from 1970-2000. The two we use are:

$$ \text{Isothermality} = 100 \cdot \frac{\text{Average difference between maximum temp and minimum temp in a month}}{\text{Annual temperature range}}$$

$$ \text{Precipitation of Driest Quarter} = \text{Total precipitation (in millimetres) that fell in driest 3 months of year} $$

To download all 19, run the following code:
  geodata::worldclim_global(var = "bio", res = 10, path = "where/you/want/the/folder/to/be")
  
Isothermality is then "wc2.1_10m_bio_2.tif", and PDQ is "wc2.1_10m_bio_17.tif". Running raster::raster() on the respective filename will load the data into R.

```{r}
bioclim_stack <- stack("processed_data/bioclim_stack.grd") # automatically includes .gri file as well
```

## Breeding Figure (supplementary material of...)

Kearney et. al (2008) used the biology of cane toads to predict where they would be able to survive. We will be using their results to inform our model, but unfortunately their data is not available online. We took a screenshot of Figure S1 from their paper (supplementary is https://www.ecography.org/sites/ecography.org/files/appendix/e5457.pdf), bounded by the northernmost, easternmost, westernmost points of Australia, and the southernmost point of Tasmania. We then converted this to a raster.

```{r}
breeding <- raster("processed_data/breeding.grd")
```

```{r}
plot(bioclim_stack)
```



## Atlas of Living Australia

The dataset comprises occurrence records of cane toads (*Rhinella marina*), downloaded from the Atlas of Living Australia (ALA). It includes geographical coordinates indicating the presence of cane toads across various regions in Australia. The ALA is a nationally recognised data repository that collates biodiversity data from multiple sources (such as from iNaturalist), facilitating research and conservation efforts. This dataset is crucial for understanding the distribution and spread of cane toads, an invasive species with significant ecological impacts. For more info see Belbin et al. (2021).

Because the galah package blocked me, occurrence data for the cane toads was obtained by pressing 'download' in this webpage https://biocache.ala.org.au/occurrences/search?q=lsid:https://biodiversity.org.au/afd/taxa/5c8e5d04-49dd-43ec-b9e0-f4e55ee82407#tab_recordsView

```{r}
df <- read_csv("processed_data/clean_toads.csv")

# create spatial dataframe
sp_df <- df
coordinates(sp_df) <- c("longitude", "latitude")
```


```{r}
## Machine Learning

### Create cell_df

For the random forest to work, we divide Australia into a grid, count the number of occurrences in each cell, get the values of the predictor variables in each cell (in our case, the WorldClim layers), and then see if the model can predict where toads should be based on the predictors. Hence, we need a dataframe where each row is a gridcell, and the columns specify its location, the number of toads in it, and the predictors.

Since we don't have the locations of where the toads aren't, we must guess (create 'pseudoabsences'). For this, we use the predictions of Kearney et. al (2008), which are in the breeding raster.

```{r}
create_cell_df <- function(data, env, years_up_to=2024) {
  data <- subset(data, year < years_up_to)

  toad_counts <- rasterize(data, env, fun = "count", background=NA)[["ID"]]
  toad_counts[breeding == 0] <- 0
  toad_count_df <- as.data.frame(toad_counts, xy = TRUE)

  cell_df <- cbind(toad_count_df, as.data.frame(extract(env, toad_count_df[,1:2], method='bilinear')))
  cell_df <- na.omit(cell_df)
  rownames(cell_df) <- NULL
  
  cell_df <- cell_df |> 
    rename(longitude = "x",
           latitude = "y",
           n_toads = "ID")
  
  cell_df$any_toads <- cell_df$n_toads > 0
  
  return(cell_df)
}
```

```{r}
cell_df <- create_cell_df(sp_df, bioclim_stack, years_up_to=2000)
```

### Create model

(Soley-Guardia, Alvarado-Serrano, & Anderson, 2024)
Since occurrence data is extremely biased by population density, we shall allow only a maximum of one observation per cell (Hazard 2). To further prevent overfitting to this bias, we limit the number of trees and maximum number of terminal nodes in each tree (Hazard 4). We also only consider mainland Australia (Hazard 6)

Isothermality and Precipitation.of.Driest.Quarter have also been thought to biologically affect toad distribution (Urban 2008?).

```{r, warning=F}
rf_model <- randomForest(any_toads ~ Isothermality + Precipitation.of.Driest.Quarter, data=cell_df,
                         ntree=100, maxnodes=50)

predictions <- predict(bioclim_stack, model = rf_model)

par(mfrow=c(1, 2))
plot(predictions, main="Random Forest Model")
plot(breeding, main="Mechanstic Model (Kearney 2009")
```

```{r}
# Plotting model 
plot(rf_model) 
  
# Variable importance plot 
varImpPlot(rf_model) 
```


## ABM

The model begins with two toads, in the two locations toads were first released (~Cairns and ~Brisbane). In discrete timesteps, and independently of other toads,
each toad then:
1. moves
2. updates its 'energy'
3. Depending on its new energy, dies, reproduces, or does nothing as appropriate.


### Behaviours and Attributes
#### Moving

Toads can only move to cells that are on land, as defined by the australia_raster. Its options are thus its $\leq8$ neighbouring cells (not including non-land cells), or its own cell. It chooses from these options randomly. In real life, toads on the western front have evolved longer legs (Phillips et. al, 2006), and move up to 5 times faster than the original toads that landed. To account for this, toads west of the NT-QLD border move three times each tick.

#### Energy

Each toad has a given energy $E_T$, $E_T \in (\infty, 1]$.

Each cell has an 'affinity' value associated with it, $A_C$, where $A \in [-1, 1]$. After moving, the toad's energy is updated using the formula

$$ E_T = E_T + |\Delta_M| A_C $$ 

Where $|\Delta_M|$ is the maximum absolute change in energy per turn. However, $E_T + \Delta_M A_C > 1$, then $E_T$ is set to 1.

The $A_C$ are defined by the following affinities raster

```{r}
predictions_agg <- resample(predictions, australia_raster)
normalised <- (predictions_agg - minValue(predictions_agg))/(maxValue(predictions_agg) - minValue(predictions_agg)) # min-max normalise
normalised[which(is.na(normalised[]))] <- 0

affinities <- (2*normalised - 1) # -1 to 1
```

#### Dying
If the toad's energy drops below die_limit, then it dies (is removed from the model/raster).

#### Reproducing

If the toad's energy is above repr_limit, then a toad with the same energy and position as its parent is created.

### Decreasing Running Time

There are ~ 200 million cane toads in Australia, which a lowly Macbook cannot cope with. Thus, two measures were implemented to decrease computational cost of the model:

1. Each tick, each cell can only have at most $4$ toads on it. Extras are killed.

2. If a cell is surrounded by cells (king's move) with $\geq4$ toads, then toads on that cell won't update (move, change energy, etc.) the next time-step. These cells and toads are called "fixed".



### Implementation

Functions and classes not here can be found in 'ABM.R' in the GitHub repository.

```{r}
max_abs_delta_energy<-4
init_energy<-1
repr_limit<-0.5
die_limit<-0.2
max_toads_per_cell<-4
min_perm_fix<-10

trackers<-vector("list", length=200)
tracker<-raster(extent(australia_raster), res=res(australia_raster))
tracker[]<-0

fixed_cells<-0*australia_raster

start<-cellFromXY(australia_raster, c(145.7844, -17.09833)) # Cairns
start2<-cellFromXY(australia_raster, c(153.0260, -27.4705)) # Brisbane

alive_toads<-c(Toad$new(pos=start, energy=init_energy, id=1),
                 Toad$new(pos=start2, energy=init_energy, id=1))
last_id<-1

sum_fixed_cells<-fixed_cells
n_cells_in_map<-cellStats(australia_raster, 'sum')
ticks <- 1:148
```

If below is unnamed-chunk-24, then it's cached


```{r run-model, cache=TRUE}
for (tick in ticks) {
  moving_toads<-Filter(function(toad) {
                            return(fixed_cells[toad$pos] != 1 & sum_fixed_cells[toad$pos] < min_perm_fix)
                          }, alive_toads)
  for (toad in moving_toads) {
    
    for (i in 1:speed(xyFromCell(australia_raster, toad$pos)[1])) {toad$move()}
    
    toad$update_energy() 

    if (toad$energy > repr_limit) { # reproduce
      new_id<-last_id + 1
      last_id<-new_id
      alive_toads<-c(alive_toads, Toad$new(pos=toad$pos, energy=init_energy, id=new_id))
    } else if (toad$energy < die_limit) { # die
      toad$die()
    }
  }
  
  fixed_cells<-focal(tracker, w=matrix(1, 3, 3), fun=function(cell) is_fixed(cell, max_toads_per_cell))
  sum_fixed_cells<-sum_fixed_cells + fixed_cells
  alive_toads<-remove_excess(alive_toads, max_toads=max_toads_per_cell)
  
  tracker<-update_tracker(tracker, alive_toads)
  trackers[[tick]]<-tracker
}

plot(tracker)
```


## Plot Results

```{r}
plot(sum_fixed_cells > 10)
```



```{r}
tracker_brick <- brick(trackers[!sapply(trackers, is.null)])
# Plot model data
k <- 7
yrs <- seq(1, nlayers(tracker_brick), by = k)
plot_list_model <- lapply(yrs, function(i) {
  tracker_polygons <- rasterToPolygons(flatten(tracker_brick[[i]]), fun = function(x) x > 0, dissolve = TRUE)
  tracker_sf <- st_as_sf(tracker_polygons)
  st_crs(tracker_sf) <- 4326

  ggplot() +
    geom_sf(data = australia_sf, fill = "grey", color = "black") +
    geom_sf(data = tracker_sf, fill = "red", color = "black") +
    theme_nothing()
})

# Plot actual data
get_spatial_data <- function(data, year_limit) {
  data %>%
    filter(year <= year_limit) %>%
    st_as_sf(coords = c("longitude", "latitude"), crs = 4326)
}
base_years <- 1930 + (10/k)*(yrs - 1)
years <- base_years[base_years < 2030]

spatial_data_list <- lapply(years, get_spatial_data, data = df)
plot_list_actual <- lapply(seq_along(years), function(i) {
  ggplot() +
    geom_sf(data = australia_sf, fill = "grey", color = "black") +
    geom_sf(data = spatial_data_list[[i]], color = "red", size = 0.5) +
    theme_nothing()
})
```

```{r, fig.height=7, fig.width=5}
# All (ChatGPT, 2024)
length_diff <- length(plot_list_model) - length(plot_list_actual)
print(length_diff)
if (length_diff >= 0) {
  plot_list_actual <- append(plot_list_actual, rep(list(NULL), length_diff))
} else {
  plot_list_model <- append(plot_list_model, rep(list(NULL), -length_diff))
}

combined_plots <- lapply(seq(4,length(plot_list_actual), 3), function(i) {
  list(plot_list_actual[[i]], plot_list_model[[i]])
})

# Replace NULLs with empty plots to maintain structure
combined_plots <- lapply(combined_plots, function(p) {
  lapply(p, function(x) if (is.null(x)) grid::nullGrob() else x)
})

# Arrange the plots in a grid layout
row_labels <- base_years[seq(4,length(plot_list_actual), 3)]
column_labels <- c("Actual", "Model")

# Create text grobs for the labels


row_label_grobs <- lapply(row_labels, function(label) {
  textGrob(label, x = unit(0.5, "npc"), y = unit(0.5, "npc"), rot = 90, just = "center",
           gp = gpar(fontsize = 14, fontface = "bold"))
})

column_label_grobs <- lapply(column_labels, function(label) {
  textGrob(label, x = unit(0.5, "npc"), y = unit(0.5, "npc"), just = "center",
           gp = gpar(fontsize = 14, fontface = "bold"))
})


# Combine the labels and plots into a grid
model_plot <- grid.arrange(
  grobs = c(
    list(nullGrob(), column_label_grobs[[1]], column_label_grobs[[2]]), # Add column labels
    do.call(c, lapply(1:length(combined_plots), function(i) {
      list(row_label_grobs[[i]], combined_plots[[i]][[1]], combined_plots[[i]][[2]])
    }))
  ),
  ncol = 3,
  heights = unit.c(unit(1, "lines"), rep(unit(1, "null"), length(combined_plots))),
  widths = unit.c(unit(1, "lines"), unit(1, "null"), unit(1, "null")),
  padding = unit(5, "mm"),
  background = rectGrob(gp = gpar(fill = "#B9DD8B", col = NA))
)
```

  top = textGrob("Model Results", gp = gpar(fontsize = 20, fontface = "bold")),

```{r}
ggsave("model_plot2.png", plot = model_plot, width = 5, height = 10, dpi = 300)
```

              
```{r}
#writeRaster(tracker_brick, "processed_data/model_trackers2", filetype="GTiff", overwrite=TRUE)
```

# References

[References you have cited throughout your text]