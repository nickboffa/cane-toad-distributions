---
title: "A title for your project"
author: "Your name and U number"
date: "Today's date"
output:  
    html_document:
        toc: true
        toc_depth: 4
        theme: cosmo
        number_sections: false
        toc_float: true
        highlight: pygments
        fig_width: 8
        fig_height: 4
---

# Word/figure count

Words: 2335
Figures:

# Location on GitHub

https://github.com/nickboffa/DS4B-final-report

# Project Outline

## Aim

To use environmental data, together with outputs from mechanistic models, to try to replicate (and then predict) the colonisation of Australia by cane toads using an agent-based model (ABM).

## Justification

Many attempts have been made to model the environmental niche of cane toads, but their range-shifting nature has made this difficult (Kearney 2010). The traditional method is the 'correlative' approach: using a set of environmental predictor variables, together with some algorithm (e.g. GAM), to predict the fundamental niche of a species - such as in Urban et. al (2008). However, particularly, with cane toads such models tend to be inaccurate, as they have not reached equilibrium with their fundamental niche (Kearney 2010). 

Kearney et. al (2008) resolved this issue by only using the physiology of cane toads to predict their fundamental niche (the 'mechanistic' approach), and found that access to breeding sites was the primary thing limiting the toads invasion inland. But this approach can only model finite biological mechanisms, and so may miss key aspects determining the toad's fundamental niche.

At the recommendation of Kearney 2008 and 2010, we will thus use this mechanistic output, that tells where the cane toads should be theoretically able to live, to define the pseudoabsence points that then inform our correlative model - this was done by Kearney 2010; however, we shall also incorporate the recent recommendations of Soley-Guardia, Alvarado-Serrano, & Anderson (2024), which earlier models have failed to incorporate (?). That said, we will ignore artificial water sources.

The key difference in this report to the primary literature is the use of an ABM. By introducing a temporal component to the model, we can predict not just where the toad's will end up, but when they will arrive there. We shall only use occurrence data up to the year 2000, so that we may validate our model with present-day data.

And clearly it's a good aim, because it turns out there's even an open project at Monash regarding it (https://supervisorconnect.it.monash.edu/projects/research/integrating-novel-technologies-and-modelling-tools-predict-species-responses)



# Beginning

```{r}
set.seed(8723)

library(R6)
library(tidyverse)
library(animation)
library(raster)
library(randomForest)
library(sf)
library(gridExtra)
library(viridis)
library(cowplot)
library(skimr)
library(grid)
```

```{r}
climate_stack <- stack("processed_data/climate_stack.grd") # automatically includes .gri file as well

df <- read_csv("processed_data/clean_toads.csv")
sp_df <- df
coordinates(sp_df) <- c("longitude", "latitude")

breeding <- raster("processed_data/breeding.grd")
```

# Create cell_df

```{r}
create_cell_df <- function(data, years_up_to=2024, res=0.5) {
  data <- subset(data, year < years_up_to)
  toad_counts <- rasterize(data, climate_stack, fun = "count", background=0)[["ID"]] # 1 per individual row? (Check later), backgroun = 0 means cells with nothing get 0
  toad_count_df <- as.data.frame(toad_counts, xy = TRUE)
  cell_df <- cbind(toad_count_df, as.data.frame(extract(climate_stack, toad_count_df[,1:2], method='bilinear'))) # adds lats and longs
  cell_df <- na.omit(cell_df)
  rownames(cell_df) <- NULL
  
  cell_df <- cell_df |> 
    rename(longitude = "x",
           latitude = "y",
           n_toads = "ID")
  
  cell_df$ribbit <- cell_df$n_toads > 0
  
  return(cell_df)
}
```


```{r}
cell_df <- create_cell_df(sp_df, years_up_to=2024, res=0.5)
head(cell_df)
```



Could remove data from clear outlier observations?

What about data before 2010?

## Actual toad counts data

```{r}
ggplot(cell_df, aes(x=longitude, y=latitude, color=log10(n_toads))) +
  geom_point(size=1.2) +
  viridis::scale_color_viridis()
```

```{r}
toad_counts <- rasterize(sp_df, climate_stack, fun = "count", background=0)[["ID"]] # 1 per individual row? (Check later), backgroun = 0 means cells with nothing get 0
plot(log10(toad_counts))
```

```{r}
plot(climate_stack)
```

# Machine learning


```{r split-data}
set.seed(12345)
n <- nrow(cell_df)
n_trains <- floor(0.7 * n)
train_idxs <- sample(1:n, n_trains)  # Sample 70% of rows for training
test_idxs <- setdiff(1:n, train_idxs)  # Use the remaining rows for testing

# Create training and testing dataframes
train <- cell_df[train_idxs, ]
test <- cell_df[test_idxs, ]
```

## Regression

```{r}
create_model <- function(data) {randomForest(n_toads ~ mean_win_temp + rel_humidity + mean_win_rain + mean_sum_rain, data=data)}
```

```{r}
rf_model1 <- randomForest(n_toads ~ mean_win_temp + rel_humidity + mean_win_rain + mean_sum_rain + breeding, data=train)

predictions1 <- predict(climate_stack, model = rf_model1)

# Visualize predictions
plot(log10(predictions1))
```


## Binary

```{r}
rf_model2 <- randomForest(as.factor(!ribbit) ~ mean_win_rain + mean_win_temp + mean_sum_rain + rel_humidity + breeding, data = train) # makes it binary. For some reason need the !?

# Might be to do with predicted2[,"TRUE"]

predictions2 <- predict(climate_stack, model = rf_model2, type='prob')

# Visualize predictions
plot(predictions2)
```

```{r}
rf_model3 <- randomForest(n_toads ~ mean_win_temp + rel_humidity + mean_win_rain + mean_sum_rain, 
                          data=train, classwt = )

predictions3 <- predict(climate_stack, model = rf_model3)

# Visualize predictions
plot(log10(predictions3))
```
predictions

# Model evaluation

```{r}
confusion_mtx = table(test$toads,test$model_toads) 
```

```{r}
# Plotting model 
plot(rf_model2) 
  
# Importance plot 
importance(rf_model2) 
  
# Variable importance plot 
varImpPlot(rf_model2) 
```

```{r}
# Plotting model 
plot(rf_model1) 
  
# Importance plot 
importance(rf_model1) 
  
# Variable importance plot 
varImpPlot(rf_model1) 
```

Model 2 is way better?

```{r}
hist(log10(predictions1))
```


# Future Predicting 

```{r}
millenium <- create_cell_df(sp_df, years_up_to=2000, res=0.4)
head(millenium)
```
```{r}
sum(millenium$n_toads) < sum(cell_df$n_toads)
```

```{r}
mill_model <- create_model(millenium)

predictions_m <- predict(climate_stack, mill_model)
```

```{r}
plot(log10(predictions1))
```
```{r}
res(australia_raster)
```


```{r}
plot(log10(predictions_m))
```

# Time

1. Create rasterbrick over time

```{r}

```

```{r}
plot(climate_stack)
```

```{r}
```

```{r}
lat_mask <- climate_stack[["mean_win_temp"]]
lat_mask <- init(lat_mask, "y") < -39.3  # Creates a logical mask for latitudes less than -40

# Apply the mask to the raster
mainland <- mask(climate_stack[["mean_win_temp"]], lat_mask, maskvalue=1)
mainland_agg <- aggregate(mainland, fact=2)
plot(mainland_agg)

australia_raster <- raster(extent(mainland_agg), res = res(mainland_agg))

# Set values to 1 where "mean_win_temp" is not NA, and 0 otherwise
australia_raster[] <- NA

# Set values to 1 where "mean_win_temp" is not NA, and 0 otherwise
australia_raster[!is.na(mainland_agg)] <- 1
australia_raster[is.na(mainland_agg)] <- 0

rm(list = c("mainland", "mainland_agg", "lat_mask")) #"mean_win_temp",
plot(australia_raster)
```


```{r}
plot(logged)
```

```{r}
predictions2_agg <- resample(predictions2, australia_raster)
predictions1_agg <- resample(predictions1, australia_raster)

logged <- log10(predictions1_agg)
sqrted <- sqrt(predictions2_agg)

input <- logged

normalised <- (input - minValue(input))/(maxValue(input) - minValue(input))
normalised[which(is.na(normalised[]))] <- 0

affinities <- (2*normalised - 1) # -1 to 1
plot(affinities)
```

# Use OOP

```{r}
library(R6)
```

```{r}
Toad <- R6Class("toad",
  public = list(
    pos=NULL,
    energy=NULL,
    id=NULL,
    # Constructor method
    initialize = function(pos, energy, id) {
      self$pos <- pos
      self$energy <- energy
      self$id <- id
    },
    move = function() {
      # Determine where it can move to that's on land
      indices <- adjacent(australia_raster, cell = self$pos, directions = 8, pairs=TRUE)[,2]
      neighboring_cells <- australia_raster[indices]
      names(neighboring_cells) <- indices
      move_options <- as.numeric(names(neighboring_cells[which(neighboring_cells == 1)])) # list of cells that are still on land
      
      # Pick destination and move it there
      destination <- sample(move_options, 1) # prob doesn't need to sum to 1 btw
      self$pos <- destination
    },
    update_energy = function() {
      self$energy <- self$energy + max_abs_delta_energy*affinities[self$pos]
      if (self$energy > 1) {self$energy <- 1}
      if (self$energy < 0) {self$energy <- 0}
    },
    die = function() {
        remove_toad <- function(any_toad) {
          any_toad$id != self$id
        }
        # Remove the toad with the specified id
        alive_toads <- Filter(remove_toad, alive_toads)
    }
  )
)
```



```{r}
update_tracker <- function(tracker, toad_list) {
  tracker[] <- 0
  tracker[australia_raster == 0] <- NA
  for (toad in toad_list) {
    tracker[toad$pos] <- tracker[toad$pos] + 1
  }
  return(tracker)
}
```

```{r}
start <- cellFromXY(australia_raster, c(145.7844, -17.09833)) # actual start of cane toad invasion
start
```

```{r}
remove_excess <- function(toads_list, max_toads=10) {
  # Count the occurrences of each 'pos' in the list
  pos_counts <- table(sapply(toads_list, function(t) t$pos))
  
  # Initialize a list to store filtered toads
  filtered_toads <- list()
  
  # Loop through each unique 'pos'
  for (pos in names(pos_counts)) {
    # Get the first 10 toads for the current 'pos'
    toads_for_pos <- toads_list[sapply(toads_list, function(t) t$pos == pos)][1:min(max_toads, pos_counts[pos])]
    
    # Add the filtered toads to the list
    filtered_toads <- c(filtered_toads, toads_for_pos)
  }
  
  return(filtered_toads)
}
```


```{r}
has_stabilised <- function(toad_counts, threshold=5) {
  toad_changes <- diff(toad_counts) # got rid of abs
  last_n_changes <- tail(toad_changes, 10) # works even if length(toad_changes) < 5
  if (max(last_n_changes) < threshold) {
    return(T)
  } else {
    return(F)
  }
}
```

```{r}
toad_long_lat <- xyFromCell(australia_raster, alive_toads[[1]]$pos)
extract(breeding, toad_long_lat)
```

```{r}
max_abs_delta_energy <- 2
init_energy <- 0.8
repr_limit <- 0.5
die_limit <- 0.2
steps_per_year <- 1

# setup
trackers <- vector("list", length = 100)
tracker <- raster(extent(australia_raster), res = res(australia_raster))
tracker[] <- 0

alive_toads <- c(Toad$new(pos = start, energy = init_energy, id=1))
last_id <- 1

num_toads_alive <- c(0, 10^6, 0)

tick <- 0
while (!has_stabilised(num_toads_alive, threshold=100-length(alive_toads))) {
  tick <- tick + 1
  for (toad in alive_toads) { # what happens when alive_toads is updated during?
    for (m in 1:steps_per_day) {toad$move()}
    toad$update_energy() 
    toad_long_lat <- xyFromCell(australia_raster, alive_toads[[1]]$pos)
    if (toad$energy > repr_limit & extract(breeding, toad_long_lat) > 0) { # reproduce
      for (i in 1:extract(breeding, toad_long_lat)) {
        new_id <- last_id + 1
        last_id <- new_id
        alive_toads <- c(alive_toads, Toad$new(pos = toad$pos, energy = init_energy, id=new_id))
      }
    }
    if (toad$energy < die_limit) { # die
      remove_toad <- function(any_toad) {
          any_toad$id != toad$id
        }
        # Remove the toad with the specified id
        alive_toads <- Filter(remove_toad, alive_toads)
    }
  }
  
  print(length(alive_toads))
  alive_toads <- remove_excess(alive_toads, max_toads=4)
  print(length(alive_toads))
  num_toads_alive <- c(num_toads_alive, length(alive_toads))
  
  tracker <- update_tracker(tracker, alive_toads)
  trackers[[tick]] <- tracker
  
  print(paste(tick, length(alive_toads)))
  
  if (length(alive_toads) == 0) {
    break
  }
}

plotting <- trackers[[tick-1]] + 0.0005*length(alive_toads)*australia_raster
plot(plotting)
```

```{r}
plot(breeding)
```

```{r}
tick
```

```{r}
plot(affinities)
```



## animate


  if (length(alive_toads) > 200) {
    alive_toads <- sample(alive_toads, 100) # instead could just remove toads from cells that have heaps already?
  }


  plot(trackers[[time_step]], main = paste("Time Step:", time_step))

```{r}
length(trackers[!sapply(trackers, is.null)])
```

```{r}
tracker_brick <- brick(trackers[!sapply(trackers, is.null)])

# Create a function to generate plots for each time step
plot_toads <- function(time_step) {
  tracker_df <- as.data.frame(trackers[[time_step]], xy = TRUE)
  names(tracker_df)[3] <- 'value' 
  tracker_df <- na.omit(tracker_df)
  tracker_df$value <- fct_rev(as.factor(tracker_df$value))
  
  p <- ggplot(tracker_df, aes(x,y)) +
    geom_raster(aes(fill = value)) +
    coord_fixed() +
    viridis::scale_fill_viridis(discrete=TRUE, option='plasma') +
    theme_void() +
    labs(main = paste("Time Step:", time_step))
  print(p)
}

# Create an animation
ani <- saveGIF({
  for (i in 1:nlayers(tracker_brick)) {
    plot_toads(i)
    Sys.sleep(0.2)  # Adjust the sleep time as needed
  }
}, interval = 0.2, fps=10)

# View the animation
ani
```




```{r}
australia_df <- as.data.frame(rasterToPoints(australia_raster), xy = TRUE)
names(australia_df) <- c("x", "y", "is_land")

# Plot using ggplot
ggplot() +
  geom_raster(data=australia_df, aes(x = x, y = y, fill = factor(is_land))) +
  geom_raster(data=plot, mapping=aes(x=x, y=y, fill = value)) +
  theme_void()
```

```{r}
plot <- as.data.frame(trackers[[7]], xy = TRUE)
names(plot)[3] <- 'value' 
plot <- na.omit(plot)
plot$value <- fct_rev(as.factor(plot$value))

aus_outline <- fortify(rasterToPolygons(australia_raster, dissolve=TRUE))

ggplot() +
  coord_fixed() +
  geom_polygon(mapping=aes(x = long, y = lat, group = group), data = aus_outline, fill='grey') +
  viridis::scale_fill_viridis(discrete=TRUE, option='mako', direction=-1) +
  geom_raster(plot, mapping = aes(x, y, fill = value)) 
  theme_void()
```
  geom_path(aes(x = long, y = lat, group = group), data = aus_outline, 
              size=1.5, col="black") +
              
```{r}
rasterToPolygons(australia_raster, dissolve=TRUE)
```


# Raw data

[Explains how and where to get the exact raw data you got]
[Is reproducible by a person (required) and a machine (ideally)]

# Data wrangling

[R chunks and prose which:]
[Tidies up your raw data, outputs tidied_data.csv]
[Cleans up your tidied data, outputs cleaned_data.csv]



# Sanity checks

[R chunks and prose which perform sanity checks on your cleaned data]
[Remember that this really just summarises that your data are OK after you've cleaned them]
[Most of the real sanity checks and data cleaning go on in the data_cleaning.Rmd file]

# Addressing the questions/aims

[This is the *main* section of your work. For example, if you are doing an EDA, this is where you would summarise it. If you are building something like a package or shiny app, a description of that package / app and demonstration of its function(s) would go here. Use appropriate sub-headings.]

# References

[References you have cited throughout your text]