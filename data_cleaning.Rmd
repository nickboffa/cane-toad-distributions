---
title: "Data Cleaning"
author: "Nicholas Boffa u7686660"
date: "2024-04-28"
output: html_document
---

```{r load-libraries}
library(tidyverse)
library(raster)
```

# Create Raster Brick

```{r create-raster-brick}
mean_win_temp <- raster("raw_data/climate/mean_winter_temp.asc")
rel_humidity <- raster("raw_data/climate/rel_humidity_9am.asc")
mean_win_rain <- raster("raw_data/climate/mean_winter_rainfall.asc")
mean_sum_rain <- raster("raw_data/climate/mean_summer_rainfall.asc")

rasters <- list(mean_win_temp, rel_humidity, mean_win_rain, mean_sum_rain)

# Define a common extent
common_extent <- extent(mean_win_temp)

for (raster in rasters) {
  common_extent <- intersect(common_extent, extent(raster))
}

# Define a common resolution
common_res <- min(res(mean_win_temp), res(rel_humidity), 
                  res(mean_win_rain), res(mean_sum_rain))

min_res_index <- which.min(c(res(mean_win_temp), res(rel_humidity), res(mean_win_rain), res(mean_sum_rain)))

raster_min_res <- rasters[[min_res_index]]

# Resample rasters to the common extent and resolution
mean_win_temp <- resample(mean_win_temp, raster_min_res, method = "bilinear")
rel_humidity <- resample(rel_humidity, raster_min_res, method = "bilinear")
mean_win_rain <- resample(mean_win_rain, raster_min_res, method = "bilinear")
mean_sum_rain <- resample(mean_sum_rain, raster_min_res, method = "bilinear")

# Create a raster brick
raster_brick <- brick(mean_win_temp, rel_humidity, mean_win_rain, mean_sum_rain)

plot(raster_brick)

#writeRaster(raster_brick, filename="processed_data/raster_brick.grd", overwrite=TRUE)
#filename = "raw_data/climate/mean_winter_rainfall"
#data <- readLines(paste0(filename, ".txt")) # http://www.bom.gov.au/climate/maps/averages/temperature/?maptype=mean&period=win&region=aus
#writeLines(data, paste0(filename, ".asc"))
```
# Toads

```{r}
toads <- read_csv("raw_data/occurrence/rhinella-marina-occurence.csv")
```

```{r}
df <- toads |> 
  dplyr::select(eventDate, year, stateProvince, decimalLatitude, decimalLongitude) |> 
  arrange(eventDate)
df <- df[(!is.na(df$decimalLatitude) & !is.na(df$decimalLongitude)),]
```

```{r create-cells}
create_cell_df <- function(data, years_to=2024, res=0.5) {
  empty_raster <- raster(extent(mean_win_temp), res = res)
  values(empty_raster) <- 0
  
  cell_df <- as.data.frame(xyFromCell(empty_raster, 1:ncell(empty_raster)))
  colnames(cell_df) <- c("decimalLongitude", "decimalLatitude")
  
  cell_df$mean_win_temp <- extract(mean_win_temp, cell_df[, c("decimalLongitude", "decimalLatitude")])
  cell_df$rel_humidity <- extract(rel_humidity, cell_df[, c("decimalLongitude", "decimalLatitude")])
  cell_df$mean_win_rain <- extract(mean_win_rain, cell_df[, c("decimalLongitude", "decimalLatitude")])
  cell_df$mean_sum_rain <- extract(mean_sum_rain, cell_df[, c("decimalLongitude", "decimalLatitude")])
  
  cell_df <- na.omit(cell_df)
  rownames(cell_df) <- NULL
  cell_df$toads <- rep(0, nrow(cell_df))
  
  data_upto_date <- subset(df, year <= years_to) # filter won't work if it's a spatial points df
  
  for (i in seq_len(nrow(data_upto_date))) {
    given_lat <- data_upto_date$decimalLatitude[i]
    given_lon <- data_upto_date$decimalLongitude[i]
    
    # Get the cell index of the nearest cell
    cell_index <- cellFromXY(empty_raster, c(given_lon, given_lat))
  
    # Get the latitude and longitude of the nearest cell
    nearest_lat_lon <- xyFromCell(empty_raster, cell_index)
    
    row_index <- which(cell_df$decimalLatitude == nearest_lat_lon[2] & cell_df$decimalLongitude == nearest_lat_lon[1])
    
    # Increment the toads count in the corresponding row
    cell_df[row_index, "toads"] <- cell_df[row_index, "toads"] + 1
  }
  
  cell_df$ribbit <- cell_df$toads > 0
  
  return(cell_df)
}
```

```{r}
unique(subset(df, year <= 2000)$year)
```

```{r}
cell_df <- create_cell_df(df, years_to=2024, res=0.5)
head(cell_df)
```



```{r}
ggplot(cell_df, aes(x=decimalLongitude, y=decimalLatitude, color=log10(toads))) +
  geom_point(size=1.8) +
  viridis::scale_color_viridis()
```
Could remove data from clear outlier observations?

What about data before 2010?




# Machine Learning

```{r}
library(randomForest)
library(caTools)
```


```{r}
run_model <- function(data) {
  set.seed(12345)

  split <- sample.split(data, SplitRatio = 0.7) 
    
  train <- subset(data, split == "TRUE") 
  test <- subset(data, split == "FALSE") 
  
  model <- randomForest(toads ~ mean_win_rain + mean_win_temp + mean_sum_rain + rel_humidity, data = train)
  
  return(model)
}
```


```{r}
set.seed(12345)

split <- sample.split(cell_df, SplitRatio = 0.7) 
  
train <- subset(cell_df, split == "TRUE") 
test <- subset(cell_df, split == "FALSE") 
```

```{r}
# Define the models
model <- randomForest(toads ~ mean_win_rain + mean_win_temp + mean_sum_rain + rel_humidity, data = train)
model2 <- randomForest(ribbit ~ mean_win_rain + mean_win_temp + mean_sum_rain + rel_humidity, data = train)
```

```{r}
test$model_toads <- predict(model, test)
test$model2_toads <- predict(model2, test)
```

```{r}
cell_df$predicted <- predict(model, cell_df)
cell_df$predicted2 <- predict(model2, cell_df)
```



```{r}
confusion_mtx = table(test$toads,test$model_toads) 
```

```{r}
# Plotting model 
plot(model2) 
  
# Importance plot 
importance(model2) 
  
# Variable importance plot 
varImpPlot(model2) 
```

Model 2 is way better?

```{r}
hist(log10(cell_df$predicted))
```


```{r}
ggplot(train, aes(x=decimalLongitude, y=decimalLatitude, color=toads)) +
  geom_point()
```

```{r}
cell_df |> 
  ggplot(aes(x=decimalLongitude, y=decimalLatitude, colour=log10(predicted))) +
    geom_point() +
    geom_point(data=cell_df |> filter(predicted < 0.5), colour='grey') +
    viridis::scale_color_viridis()
```

```{r}
millenium |> 
  ggplot(aes(x=decimalLongitude, y=decimalLatitude, colour=log10(predicted))) +
    geom_point() +
    geom_point(data=millenium |> filter(predicted < 0.2), colour='grey') +
    viridis::scale_color_viridis()
```


```{r}
test |> 
  ggplot(aes(x=decimalLongitude, y=decimalLatitude, colour=model2_toads)) +
    geom_point() +
    #geom_point(data=cell_df |> filter(predicted2 < 0.5), colour='grey') +
    viridis::scale_color_viridis()
```




# Future Predicting 

```{r}
millenium <- create_cell_df(df, years_to=2000, res=0.5)
head(millenium)



mill_model <- run_model(millenium)

millenium$predicted <- predict(mill_model, millenium)

ggplot(millenium, aes(x=decimalLongitude, y=decimalLatitude, color=log10(predicted))) +
  geom_point(size=1.8) +
  viridis::scale_color_viridis()
```
```


Varroa mites
Fire ants
Proximate Bayesian Modelling
Use already-made shapefiles of cane toad distributions

Amniote life history database


http://www.bom.gov.au/climate/maps/averages/rainfall/
